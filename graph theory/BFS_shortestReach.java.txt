/*


onsider an undirected graph where each edge is the same weight. Each of the nodes is labeled consecutively.

You will be given a number of queries. For each query, you will be given a list of edges describing an undirected graph. After you create a representation of the graph, you must determine and report the shortest distance to each of the other nodes from a given starting position using the breadth-first search algorithm (BFS). Distances are to be reported in node number order, ascending. If a node is unreachable, print  for that node. Each of the edges weighs 6 units of distance.

Sample i/p

2
4 2
1 2
1 3
1
3 1
2 3
2

Sample Output

6 6 -1
-1 6

*/

import java.io.*;
import java.math.*;
import java.security.*;
import java.text.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.regex.*;

public class Solution {

    // Complete the bfs function below.
    static int[] bfs(int n, int m, int[][] edges, int s) {


        int[] distanceVector = new int[n];
        boolean[] visited = new boolean[n];

        Arrays.setAll(distanceVector, p -> p == s-1 ? 0 : -1);
        for (int i=0;i<n;i++) visited[i]=false;
        visited[s-1] = true;
        
        Queue<Integer> queue = new LinkedList<>();
        queue.add(s);

        Map<Integer, Set<Integer>> edgeMap = new HashMap<>();

        for (int i=0;i<m;i++) {
            if (edgeMap.containsKey(edges[i][0])) {
                Set<Integer> edgeSet = edgeMap.get(edges[i][0]);
                edgeSet.add(edges[i][1]);
                edgeMap.put(edges[i][0],edgeSet);
               
            } else {
                Set<Integer> edgeSet = new HashSet<>();
                edgeSet.add(edges[i][1]);
                edgeMap.put(edges[i][0],edgeSet);
            }

            if (edgeMap.containsKey(edges[i][1])) {
                Set<Integer> edgeSet = edgeMap.get(edges[i][1]);
                edgeSet.add(edges[i][0]);
                edgeMap.put(edges[i][1],edgeSet);
               
            } else {
                Set<Integer> edgeSet = new HashSet<>();
                edgeSet.add(edges[i][0]);
                edgeMap.put(edges[i][1],edgeSet);
            }
        }


        while(queue.size() !=0 ) {
            
            int currentElement = queue.poll();
            
            // iterating over edges matrix to find neighbours of current vertex and update
            Set <Integer> edgeSet = edgeMap.get(currentElement);
            
            for (int adjacentElement: edgeSet) {

                if (!visited[adjacentElement-1] && distanceVector[adjacentElement-1] == -1) {
                        distanceVector[adjacentElement-1] = distanceVector[currentElement - 1] + 6;
                        visited[adjacentElement-1] = true;
                        queue.add(adjacentElement);
                    }
            }
            


        }
    

        int [] resultArray = new int[n-1];


        // Copy the elements from starting till index 
        // from original array to the other array 
        System.arraycopy(distanceVector, 0, resultArray, 0, s-1); 
  
        // Copy the elements from index + 1 till end 
        // from original array to the other array 
        System.arraycopy(distanceVector, s, 
                         resultArray, s-1, 
                         n - s); 
  System.out.println();
    return resultArray;

    }

    private static final Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) throws IOException {
        BufferedWriter bufferedWriter = new BufferedWriter(new FileWriter(System.getenv("OUTPUT_PATH")));

        int q = scanner.nextInt();
        scanner.skip("(\r\n|[\n\r\u2028\u2029\u0085])?");

        for (int qItr = 0; qItr < q; qItr++) {
            String[] nm = scanner.nextLine().split(" ");

            int n = Integer.parseInt(nm[0]);

            int m = Integer.parseInt(nm[1]);

            int[][] edges = new int[m][2];

            for (int i = 0; i < m; i++) {
                String[] edgesRowItems = scanner.nextLine().split(" ");
                scanner.skip("(\r\n|[\n\r\u2028\u2029\u0085])?");

                for (int j = 0; j < 2; j++) {
                    int edgesItem = Integer.parseInt(edgesRowItems[j]);
                    edges[i][j] = edgesItem;
                }
            }

            int s = scanner.nextInt();
            scanner.skip("(\r\n|[\n\r\u2028\u2029\u0085])?");

            int[] result = bfs(n, m, edges, s);

            for (int i = 0; i < result.length; i++) {
                bufferedWriter.write(String.valueOf(result[i]));

                if (i != result.length - 1) {
                    bufferedWriter.write(" ");
                }
            }

            bufferedWriter.newLine();
        }

        bufferedWriter.close();

        scanner.close();
    }
}
